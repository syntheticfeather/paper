# 自上而下和自下而上什么区别

## 🎯 一、我们要解决的问题：程序是不是“合法”的？

想象一下，你是一个老师，学生交来一个数学表达式作业：

> `3 + 4 * 5`

你的任务不是算出结果，而是判断这个表达式写得对不对 —— 它是否符合数学的语法规则？

比如：
- `3 + + 4` ❌ 不对（两个加号连着）
- `* 3 4` ❌ 不对（符号不能开头）
- `3 + 4 * 5` ✅ 对

在编译器中，这个“判断语句是否合法”的工作，就叫做 **语法分析（Parsing）**。

---

## 🧩 二、什么是“文法”？—— 给语言定规则

为了让计算机知道什么是对的、什么是错的，我们需要先定义一套 **语法规则**，这叫“文法”（Grammar）。

举个简单例子，我们只允许这样的表达式：

```
E → E + T     （表达式 = 表达式 + 项）
E → T         （表达式也可以只是一个“项”）
T → T * F     （项 = 项 * 因子）
T → F         （项也可以只是一个“因子”）
F → (E)       （因子可以是括号里的表达式）
F → i         （因子可以是一个数字或变量，用 i 表示）
```

这些规则就像搭积木的说明书：
- `i` 是最小的积木块（比如数字 `3`）。
- `F` 可以是 `i` 或 `(E)`。
- `T` 是由 `F` 通过 `*` 连接起来的。
- `E` 是由 `T` 通过 `+` 连接起来的。

我们的目标：判断像 `i + i * i` 这样的输入，能不能按照这些规则“拼出来”。

---

## 🔄 三、两种思路：从哪一头开始分析？

现在问题来了：我们怎么判断一个句子是否合法？

有两种完全相反的策略：

| 方法 | 自上而下（Top-down） | 自下而上（Bottom-up） |
|------|----------------------|------------------------|
| 起点 | 从最大的结构开始（如 `E`） | 从最小的单词开始（如 `i`） |
| 方向 | 从“整体”往“细节”拆 | 从“细节”往“整体”拼 |
| 比喻 | 先画轮廓，再填细节 | 先堆砖头，再盖房子 |

下面我们分别详细讲解。

---



## 🏗️ 四、自上而下分析（Top-down）—— “我先假设它是对的”

### 💡 核心思想：
从文法的起始符号 `E` 开始，**一步步猜测**应该用哪个规则去展开它，直到匹配输入串。

### 🧩 比喻：拼图游戏
你想拼一幅完整的图（比如一只猫），但你不知道具体怎么拼。你从“这是一只猫”这个想法出发，然后猜：
- 猫有头 → 我找头的拼图
- 头有耳朵 → 我找耳朵的拼图
- ……

如果某一步猜错了（比如你找了狗耳朵），你就得**回退**，换另一个可能。

### 🔍 实例：分析 `i + i`

输入：`i + i`

1. **起点**：我们知道所有表达式都从 `E` 开始。
   - 当前目标：匹配 `E`
2. 看规则：`E → E + T` 或 `E → T`
   - 我们先试试 `E → T`（简单一点）
3. 现在目标变成匹配 `T`
   - `T → T * F` 或 `T → F`
   - 试试 `T → F`
4. 目标变成匹配 `F`
   - `F → (E)` 或 `F → i`
   - 输入第一个是 `i`，所以用 `F → i`
5. 匹配成功一个 `i`！
6. 现在栈里是 `E → T → F → i`，但我们还有 `+ i` 没处理。
   - 发现不对！因为 `E → T` 只能生成单个 `i`，不能处理 `+`。

7. **回退！** 放弃之前的猜测。
8. 换一条路：`E → E + T`
   - 第一个 `E` 要匹配 `i` → 再递归用 `E → T → F → i`
   - 匹配 `+`
   - `T` 匹配第二个 `i`（同样 `T → F → i`）
9. 成功匹配整个 `i + i`！

✅ 结论：合法！

> ⚠️ 注意：这种方法需要“猜测”和“回溯”，效率可能不高。但有一种优化版本叫“预测分析”，可以避免回溯。

---

## 🔼 五、自下而上分析（Bottom-up）—— “我看到什么就拿什么”

### 💡 核心思想：
从输入的单词开始，**一步步把小部分归约为更大的结构**，直到最后变成 `E`。

### 🧩 比喻：搭积木
你有一堆散落的积木块（`i`, `+`, `*`），你要把它们一块块拼起来：
- 先把两个 `i` 分别变成 `F`（因子）
- 再把 `F` 变成 `T`（项）
- 把 `T + T` 合并成 `E`（表达式）

最终如果只剩下 `E`，就成功了。

### 🔍 实例：分析 `i + i`

输入：`i + i`

我们有一个“工作区”（叫栈），用来存放已经处理的部分。

| 步骤 | 栈（已处理） | 剩余输入 | 动作 |
|------|---------------|----------|------|
| 1 | `#` | `i + i#` | 移进 `i` |
| 2 | `# i` | `+ i#` | 发现 `i` 可以归约为 `F`（因 `F → i`）→ 归约 |
| 3 | `# F` | `+ i#` | `F` 可归约为 `T`（因 `T → F`）→ 归约 |
| 4 | `# T` | `+ i#` | 移进 `+` |
| 5 | `# T +` | `i#` | 移进 `i` |
| 6 | `# T + i` | `#` | `i → F → T` → 归约两次 |
| 7 | `# T + T` | `#` | 发现 `T + T` 符合 `E → T + T`？等等，原规则是 `E → E + T`，但我们可以调整为 `E → T + T` 或通过递归匹配 |
| 8 | `# E` | `#` | 接受！✅ |

这个过程就是不断把底部的小结构“往上提”，最终形成一个完整的表达式。

---

## 🆚 六、关键区别总结

| 对比项 | 自上而下（Top-down） | 自下而上（Bottom-up） |
|--------|------------------------|------------------------|
| 起点 | 从开始符号 `E` 出发 | 从输入的第一个单词出发 |
| 方向 | 展开（推导）：`E → ...` | 归约：`i → F → T → E` |
| 思维方式 | “我想生成这个句子” | “我看到了这些词，怎么往上拼” |
| 常见方法 | 递归下降、LL分析 | 算符优先、LR分析 |
| 优点 | 直观，容易手写 | 强大，能处理更多文法 |
| 缺点 | 可能需要回溯 | 概念较抽象，表复杂 |

---

## 🎯 七、为什么叫“LR”？

这是自下而上分析中最强大的一种，叫 **LR(k)** 分析：

- **L**：从左到右扫描输入（Left-to-right）
- **R**：构造一个**最右推导**的逆过程（Rightmost derivation in reverse）
- **k**：向前看 k 个字符（通常 k=1）

> 简单说：它一边从左往右读单词，一边在心里倒着想：“这个句子如果是从 `E` 推导出来的，最后一步一定是哪个规则？”

---

## 🧠 八、一句话总结

- **自上而下**：  
  > “我知道一切表达式都从 `E` 开始，那我就从 `E` 出发，一步步往下猜，看能不能猜出你写的这个句子。”

- **自下而上**：  
  > “我不关心你从哪开始，我只看眼前这些词。只要我能把它们一步步合并成更大的结构，最后变成 `E`，那就说明你是对的。”

---

## ✅ 九、小练习（巩固理解）

试着用自下而上的方式分析 `i * i`：

1. 移进 `i` → 栈: `i`
2. `i → F` → 栈: `F`
3. `F → T` → 栈: `T`
4. 移进 `*` → 栈: `T *`
5. 移进 `i` → 栈: `T * i`
6. `i → F` → 栈: `T * F`
7. `T * F → T`（根据 `T → T * F`）→ 栈: `T`
8. `T → E` → 栈: `E` → 接受！

✅ 成功！

----
---
```

```
---
---

# LR分析法详解

好的！我们现在就用一个**完整的、带 ACTION 和 GOTO 表的例子**，来深入讲解 LR 分析的整个过程。

我们将使用你提供的 PDF 文件中的文法和分析表，一步一步地“走一遍”分析器是如何工作的。

---

## 📚 一、准备工作：文法与分析表

### ✅ 1. 文法 G(E)（拓广后）

这是我们要分析的表达式文法。为了方便构造分析器，我们先进行**拓广**：引入一个新的开始符号 `S'`，并添加规则 `S' → E`。

```
(0) S' → E      ← 拓广产生式
(1) E  → E + T
(2) E  → T
(3) T  → T * F
(4) T  → F
(5) F  → (E)
(6) F  → i
```

> ⚠️ 注意：产生式编号从 0 开始，归约时用编号。

### ✅ 2. SLR(1) 分析表（来自你的 PDF）(先不考虑这部分怎么来的)

| 状态 | ACTION|      |       |       |       |       | GOTO |||
|------|--------|--------|-------|-------|-------|-------|------|-|-|
|      | **i**          | **+**  |**\*** | **(** | **)** | **#** | **E**| **T**| **F**|
| **0**| s5             |        |       | s4    |       |       | 1    | 2    | 3    |
| **1**|                | s6     |       |       |       | acc   |      |      |      |
| **2**|                | r2     | s7    |       | r2    | r2    |      |      |      |
| **3**|                | r4     | r4    |       | r4    | r4    |      |      |      |
| **4**| s5             |        |       | s4    |       |       | 8    | 2    | 3    |
| **5**|                | r6     |r6     |       | r6    | r6    |      |      |      |
| **6**| s5             |        |       | s4    |       |       |      | 9    | 3    |
| **7**| s5             |        |       | s4    |       |       |      |      | 10   |
| **8**|                | s6     |       |       | s11   |       |      |      |      |
| **9**|                |r1      | s7    |       | r1    | r1    |      |      |      |
| **10**|               | r3     |     r3|       | r3    | r3    |      |      |      |
| **11**|               | r5     |     r5|       | r5    | r5    |      |      |      |

> 🔑 符号说明：
- `sN`：移进，并进入状态 N
- `rK`：用第 K 条产生式归约
- `acc`：接受
- 空白：报错

---

## 🎯 二、目标：分析输入串 `(i)` 是否合法

我们来分析一个简单的括号表达式：`(i)`

输入串为：`( i ) #`（`#` 表示结束）

---

## 🧩 三、分析过程详解（一步步走）

我们维护两个栈：

- **状态栈**：存放当前所处的状态编号
- **符号栈**：存放已识别的文法符号（终结符或非终结符）

初始状态：

```
状态栈: [0]
符号栈: [#]
输入: ( i ) #
```

现在开始！

---

### 🔹 步骤 1：读入 `(`

- 当前状态：0
- 当前输入：`(`
- 查表：`ACTION[0, (] = s4`
- 动作：**移进**，将状态 4 和符号 `( `压入栈

```
状态栈: [0, 4]
符号栈: [# (]
输入: i ) #
```

---

### 🔹 步骤 2：读入 `i`

- 当前状态：4
- 当前输入：`i`
- 查表：`ACTION[4, i] = s5`
- 动作：**移进**，将状态 5 和符号 `i` 压入栈

```
状态栈: [0, 4, 5]
符号栈: [# ( i]
输入: ) #
```

---

### 🔹 步骤 3：当前是 `)`，但栈顶是 `i`

- 当前状态：5
- 当前输入：`)`
- 查表：`ACTION[5, )] = r6`
- 动作：**归约**，使用第 6 条产生式 `F → i`

> 归约步骤：
1. 弹出 `r=1` 个状态和符号（因为 `F → i` 长度为 1）
2. 栈顶回到状态 4
3. 查 `GOTO[4, F] = 3`
4. 将状态 3 和符号 `F` 压入栈

```
状态栈: [0, 4, 3]
符号栈: [# ( F]
输入: ) #
```

---

### 🔹 步骤 4：继续归约 `F → T`

- 当前状态：3
- 当前输入：`)`
- 查表：`ACTION[3, )] = r4`
- 动作：**归约**，使用第 4 条产生式 `T → F`

> 归约步骤：
1. 弹出 1 个状态和符号
2. 栈顶回到状态 4
3. 查 `GOTO[4, T] = 2`
4. 将状态 2 和符号 `T` 压入栈

```
状态栈: [0, 4, 2]
符号栈: [# ( T]
输入: ) #
```

---

### 🔹 步骤 5：继续归约 `T → E`

- 当前状态：2
- 当前输入：`)`
- 查表：`ACTION[2, )] = r2`
- 动作：**归约**，使用第 2 条产生式 `E → T`

> 归约步骤：
1. 弹出 1 个状态和符号
2. 栈顶回到状态 4
3. 查 `GOTO[4, E] = 8`
4. 将状态 8 和符号 `E` 压入栈

```
状态栈: [0, 4, 8]
符号栈: [# ( E]
输入: ) #
```

---

### 🔹 步骤 6：读入 `)`

- 当前状态：8
- 当前输入：`)`
- 查表：`ACTION[8, )] = s11`
- 动作：**移进**，将状态 11 和符号 `)` 压入栈

```
状态栈: [0, 4, 8, 11]
符号栈: [# ( E )]
输入: #
```

---

### 🔹 步骤 7：准备归约 `(E) → F`

- 当前状态：11
- 当前输入：`#`
- 查表：`ACTION[11, #] = r5`
- 动作：**归约**，使用第 5 条产生式 `F → (E)`

> 归约步骤：
1. 弹出 3 个状态和符号（因为 `(E)` 长度为 3）
2. 栈顶回到状态 0
3. 查 `GOTO[0, F] = 3`
4. 将状态 3 和符号 `F` 压入栈

```
状态栈: [0, 3]
符号栈: [# F]
输入: #
```

---

### 🔹 步骤 8：归约 `F → T`

- 当前状态：3
- 当前输入：`#`
- 查表：`ACTION[3, #] = r4`
- 动作：**归约**，使用第 4 条产生式 `T → F`

> 归约步骤：
1. 弹出 1 个状态和符号
2. 栈顶回到状态 0
3. 查 `GOTO[0, T] = 2`
4. 将状态 2 和符号 `T` 压入栈

```
状态栈: [0, 2]
符号栈: [# T]
输入: #
```

---

### 🔹 步骤 9：归约 `T → E`

- 当前状态：2
- 当前输入：`#`
- 查表：`ACTION[2, #] = r2`
- 动作：**归约**，使用第 2 条产生式 `E → T`

> 归约步骤：
1. 弹出 1 个状态和符号
2. 栈顶回到状态 0
3. 查 `GOTO[0, E] = 1`
4. 将状态 1 和符号 `E` 压入栈

```
状态栈: [0, 1]
符号栈: [# E]
输入: #
```

---

### 🔹 步骤 10：接受！

- 当前状态：1
- 当前输入：`#`
- 查表：`ACTION[1, #] = acc`
- 动作：**接受！✅**

分析成功！输入串 `(i)` 是一个合法的表达式。

---

## 📊 四、完整过程表格总结

| 步骤 | 状态栈 | 符号栈 | 输入 | 动作 | 说明 |
|------|--------|--------|------|------|------|
| 1 | 0 | # | (i)# | s4 | 移进 `(`符号，移进`4`状态|
| 2 | 0 4 | #( | i)# | s5 | 移进 `i`，移进`5`状态 |
| 3 | 0 4 5 | #(i | )# | r6 | `F → i`，移除 `5` 状态，回到 `4` 状态，GOTO(4, F) = 3，移进 `3` 状态 |
| 4 | 0 4 3 | #(F | )# | r4 | `T → F`，移除 `3` 状态，回到 `4` 状态，GOTO(4, T) = 2，移进 `2` 状态 |
| 5 | 0 4 2 | #(T | )# | r2 | `E → T`，移除 `2` 状态，回到 `4` 状态，GOTO(4, E) = 8，移进 `8` 状态 |
| 6 | 0 4 8 | #(E | )# | s11 | 移进 `)`，移进`11`状态 |
| 7 | 0 4 8 11 | #(E) | # | r5 | `F → (E)`，移除 `11, 8, 4` 状态，回到 `0` 状态，GOTO(0, F) = 3，移进 `3` 状态 |
| 8 | 0 3 | #F | # | r4 | `T → F`，移除`3`状态，回到`0`状态，GOTO(0, T) = 2，移进`2`状态 |
| 9 | 0 2 | #T | # | r2 | `E → T`，移除`2`状态，回到`0`状态，GOTO(0, E) = 1，移进`1`状态 |
| 10 | 0 1 | #E | # | acc | 接受！ |

---

## 🔍 五、关键点解析

### 1. 为什么能正确处理括号？

- 因为文法中有 `F → (E)` 这条规则。
- 当我们看到 `( ... )` 并且中间已经规约为 `E` 时，就可以把整个 `(E)` 规约为 `F`。
- 这体现了自下而上分析的强大之处：它能自然地处理嵌套结构。

### 2. 状态的作用是什么？

每个状态代表了分析器在某个时刻的“知识”或“预期”。

- 状态 0：刚开始，期待 `i` 或 `(`
- 状态 4：刚读入 `(`，期待一个 `E`（即 `i`, `(` 等）
- 状态 5：刚读入 `i`，下一步只能归约（不能移进）
- 状态 1：已经得到完整的 `E`，如果输入结束就接受

### 3. ACTION 和 GOTO 的分工

- **ACTION**：决定对**终结符**（如 `i`, `+`, `*`, `(`, `)`, `#`）做什么（移进/归约/接受/报错）
- **GOTO**：决定对**非终结符**（如 `E`, `T`, `F`）归约后，应该进入哪个状态

---

## ✅ 六、总结

通过这个完整的例子，你应该已经理解了：

- LR 分析器如何通过 **状态栈 + 符号栈** 工作
- 如何查 **ACTION 表** 决定移进或归约
- 如何查 **GOTO 表** 在归约后进入下一个状态
- 整个过程是一个**驱动式的自动机**，完全由表格控制
- 自下而上分析能正确处理复杂的嵌套结构（如括号）

---
---
```

```
---
---

# 先看看概念，什么是项目，什么是闭包

当然可以！我们现在就来**用最通俗、最生活化的方式**，深入讲解“项目”和“闭包”这两个概念。

你不需要任何编译原理基础，我会用一个“拼图游戏”的比喻，带你完全理解它们到底是什么、为什么需要它们。

---

## 🧩 一、背景：我们在做什么？

想象你是一个机器人，任务是判断一句话是不是合法的数学表达式，比如：

> `i + i * i`

你不会算它的值，你只关心它写得对不对。

为了完成这个任务，你有一本《语法说明书》（文法），上面写着规则：

```
E → E + T     （表达式 = 表达式 + 项）
E → T         （表达式也可以只是一个“项”）
T → T * F     （项 = 项 * 因子）
T → F         （项也可以只是一个“因子”）
F → (E)       （因子可以是括号里的表达式）
F → i         （因子可以是一个数字或变量）
```

你的工作就是根据这些规则，一步步检查输入是否合法。

---

## 🔍 二、什么是“项目”？—— 拼图的“进度条”

### 💡 核心比喻：你在玩一个拼图游戏

每一条规则就像一个拼图模板。比如 `E → E + T` 这个模板，有三个空位：左边放一个 `E`，中间放 `+`，右边放一个 `T`。

但你不是一下子就把整个拼图放好，而是**一步一步来**。

于是，你用一个小红旗（•）插在模板上，表示：“我现在拼到这一步了”。

这就是 **项目（Item）**。

### 🎯 例子：规则 `E → E + T` 的四个“项目”

| 项目 | 含义 |
|------|------|
| `E → • E + T` | 我还没开始，准备找第一个 `E` |
| `E → E • + T` | 我已经找到 `E` 了，现在要找 `+` |
| `E → E + • T` | 我已经看到 `E +`，现在要找 `T` |
| `E → E + T •` | 我已经完整看到 `E + T`，可以归约了！ |

> ✅ **项目 = 规则 + 小红旗（•）**
>
> 红旗在哪，表示你当前分析到了哪。

### 🧠 为什么需要项目？

因为分析器需要记住：“我现在正在尝试匹配哪条规则，已经看到了什么，接下来要找什么”。

项目就是用来记录这个“进度”的。

---

## 🌱 三、什么是“闭包”（CLOSURE）？—— “我还需要准备什么？”

现在问题来了：当你看到 `E → • E + T` 时，你知道下一步要找一个 `E`。

但 `E` 是什么？它不是一个原始积木块（终结符），而是一个“大结构”，它可以是：

- `E → E + T`
- `E → T`

所以，为了准备好匹配 `E`，你也必须知道 `E` 可能长什么样。

这就引出了 **闭包（CLOSURE）**。

### 💡 闭包的核心思想：

> “如果我现在要等一个非终结符 `X`，那么我也应该准备好所有 `X` 可能展开成的样子。”

### 🎯 举例：初始状态 I0 的闭包

我们从最开始的状态出发：

你刚启动，目标是匹配整个表达式，也就是从 `S' → • E` 开始。

所以初始项目是：

```
S' → • E
```

但你现在要等一个 `E`，那 `E` 可能是什么？查说明书：

- `E → E + T`
- `E → T`

所以你也应该把它们加进来，而且红旗放在最前面（因为你还没看到它们）：

```
E → • E + T
E → • T
```

但这还没完！`E → • T` 表示你要等一个 `T`，那 `T` 又是什么？

查说明书：

- `T → T * F`
- `T → F`

所以加上：

```
T → • T * F
T → • F
```

继续！`T → • F` 表示你要等一个 `F`，那 `F` 是什么？

- `F → (E)`
- `F → i`

所以加上：

```
F → • (E)
F → • i
```

现在，所有以 `•` 开头的项目都齐了。你不再需要展开更多，因为 `( ` 和 `i` 是原始符号（终结符），可以直接从输入中读取。

最终得到的完整项目集就是 **闭包（CLOSURE）**：

```
I0:
  S' → • E
  E  → • E + T
  E  → • T
  T  → • T * F
  T  → • F
  F  → • (E)
  F  → • i
```

> ✅ **闭包 = 把一个项目集中隐含的所有可能性全部展开补全**

它回答的问题是：“我现在可能处于哪些情况？”

---

## 🧩 四、闭包的生活化比喻

### 🎯 比喻：你要做一顿饭

你的目标是：**上菜（S' → • 菜）**

但“菜”怎么来？有两种做法：

1. `菜 → 炒菜 + 米饭`
2. `菜 → 汤`

所以你也得准备：
- `炒菜 → • 切菜 + 炒`
- `汤 → • 煮汤`

但“切菜”又是什么？
- `切菜 → • 切土豆`
- `切菜 → • 切肉`

“煮汤”呢？
- `煮汤 → • 煮鸡汤`
- `煮汤 → • 煮蔬菜汤`

直到你发现“切土豆”、“切肉”、“煮鸡汤”这些动作不能再分解了，你才停下来。

这个“把所有可能的准备工作都列出来”的过程，就是 **闭包**。

---

## 🔄 五、闭包的算法（简单说）

给定一个项目集 `I`，计算它的闭包：

1. 把 `I` 中所有项目加入结果。
2. 对于每个形如 `A → α • B β` 的项目：
   - 如果 `B → γ` 是一个产生式，
   - 那么把 `B → • γ` 加入结果（如果还没在的话）。
3. 重复步骤 2，直到没有新项目可以加入。

---

## 📌 六、总结：项目与闭包的关系

| 概念 | 类比 | 作用 |
|------|------|------|
| **项目** | 拼图的进度条<br>“我已经拼到这一步了” | 记录当前分析进度 |
| **项目集** | 当前可能的所有拼图进度 | 表示一个“状态” |
| **闭包** | 把所有可能的拼图模板都准备好 | 补全状态中隐含的可能性 |
| **GO函数** | 移动红旗后进入下一个状态 | 状态转移 |

---

## ✅ 七、小练习：手动计算一个闭包

假设你有项目集：

```
I: { E → E + • T }
```

计算 `CLOSURE(I)`。

**步骤**：

1. 初始：`E → E + • T`
2. 发现要等 `T`，查规则：
   - `T → T * F`
   - `T → F`
3. 加入：
   - `T → • T * F`
   - `T → • F`
4. 发现 `T → • F`，要等 `F`，查规则：
   - `F → (E)`
   - `F → i`
5. 加入：
   - `F → • (E)`
   - `F → • i`

最终闭包：

```
CLOSURE(I):
  E → E + • T
  T → • T * F
  T → • F
  F → • (E)
  F → • i
```

✅ 完成！

---

现在你明白了吗？项目是“进度条”，闭包是“准备工作清单”。它们共同帮助LR分析器知道：“我现在在哪，接下来可能遇到什么”。

如果你想继续了解“GO函数”是怎么工作的，或者“状态图”长什么样，我们可以继续讲！
---
---
```

```
---
---

# 好了看分析法到底怎么搞出来的，文法如何拓广，ACTION表和GOTO表构造规则是什么？最终表是怎么构造出来的？

我们将使用一个非常简单的文法：

> **S → a S | b**

这个文法可以生成像 `b`, `a b`, `a a b`, `a a a b` 这样的字符串 —— 任意多个 `a` 后跟一个 `b`。

它足够简单，我们可以**手动完成所有步骤**，不会被复杂性干扰，专注于理解“项目”、“闭包”、“GO函数”和“分析表”的关系。

---

## 📚 一、第一步：拓广文法（Augment the Grammar）

原始文法：
```
S → a S
S → b
```

为了构造分析器，我们引入一个新的开始符号 `S'`，并添加规则：

```
(0) S' → S
(1) S  → a S
(2) S  → b
```

> ✅ 拓广的目的：让分析器有唯一的接受状态（当归约到 `S' → S` 时）。

---

## 🧩 二、第二步：构造 LR(0) 项目

每个产生式可以拆成多个项目（加“点” `•`）：

| 产生式 | 项目 |
|--------|------|
| S' → S | `S' → • S`<br>`S' → S •` |
| S → a S | `S → • a S`<br>`S → a • S`<br>`S → a S •` |
| S → b  | `S → • b`<br>`S → b •` |

这些项目就是我们所有可能的“进度条”。

---

## 🏗️ 三、第三步：构造项目集规范族（所有状态）

我们从初始状态开始，逐步构造所有可能的状态。

### ✅ 步骤 1：构造 I0（初始状态）

初始项目：`S' → • S`

计算 `CLOSURE({S' → • S})`

- `S' → • S`：要等 `S`
- `S` 可以是 `S → a S` 或 `S → b`，所以加入：
  - `S → • a S`
  - `S → • b`

没有其他非终结符在 `•` 后面（`a` 和 `b` 是终结符），所以闭包完成。

```
I0:
  S' → • S      -- 目标是匹配 S
  S  → • a S    -- S 可以是 a S
  S  → • b      -- 或者是 b
```

✅ `I0` 是我们的开始状态。

---

### ✅ 步骤 2：从 I0 计算 GO 函数

#### 🔹 GO(I0, S) = ?

- `I0` 中 `• S` 的项目：`S' → • S`
- 移动点：`S' → S •`
- 闭包：没有非终结符在 `•` 后，所以就是它自己。

```
I1:
  S' → S •
```

✅ `GO(I0, S) = I1`

---

#### 🔹 GO(I0, a) = ?

- `I0` 中 `• a` 的项目：`S → • a S`
- 移动点：`S → a • S`
- 现在，`• S` 表示要等 `S`，所以需要展开 `S` 的所有可能（取闭包）

计算 `CLOSURE({S → a • S})`：

- `S → a • S`
- `S → • a S`（因为 `S` 可以是 `a S`）
- `S → • b`（因为 `S` 可以是 `b`）

```
I2:
  S → a • S
  S → • a S
  S → • b
```

✅ `GO(I0, a) = I2`

---

#### 🔹 GO(I0, b) = ?

- `I0` 中 `• b` 的项目：`S → • b`
- 移动点：`S → b •`

```
I3:
  S → b •
```

✅ `GO(I0, b) = I3`

---

### ✅ 步骤 3：从 I2 继续扩展

#### 🔹 GO(I2, S) = ?

- `I2` 中 `• S` 的项目：`S → a • S`
- 移动点：`S → a S •`

```
I4:
  S → a S •
```

✅ `GO(I2, S) = I4`

---

#### 🔹 GO(I2, a) = ?

- `I2` 中 `• a` 的项目：`S → • a S`
- 移动点：`S → a • S`
- 闭包后：和 `I2` 一样！

```
I2:
  S → a • S
  S → • a S
  S → • b
```

所以 `GO(I2, a) = I2`

---

#### 🔹 GO(I2, b) = ?

- `I2` 中 `• b` 的项目：`S → • b`
- 移动点：`S → b •`

```
I3:
  S → b •
```

✅ `GO(I2, b) = I3`

---

### ✅ 所有状态汇总

我们一共得到了 **5 个状态**：

```
I0:
  S' → • S      || 移动点 S -> S • (I1)     || GO(I0, S) = I1
  S  → • a S    || 移动点 S -> a • S (I2)   || GO(I0, a) = I2
  S  → • b      || 移动点 S -> b • (I3)     || GO(I0, b) = I3

I1:
  S' → S •      || 没得移动了，但我们知道这个文法编号是0      

I2:
  S → a • S     || 移动点 S -> a S • (I4)   || GO(I2, S) = I4
  S → • a S     || 移动点 S -> a • S (I2)   || GO(I2, a) = I2
  S → • b       || 移动点 S -> b • (I3)     || GO(I2, b) = I3

I3:
  S → b •       || 没得移动了，但我们知道这个文法编号是2

I4:
  S → a S •     || 没得移动了，但我们知道这个文法编号是1
```

---

## 📋 四、构造 ACTION 和 GOTO 表

### 1. GOTO 表（非终结符转移）

**构造规则:(看上面的表)**

`GO(Ij, XXX(这里为非终结符)) = Ik`

**那么:**

`GOTO[Ij, XXX] = Ik` 

| GOTO | S  |
|------|----|
| 0    | 1  |
| 2    | 4  |

（其他为空）

---

### 2. ACTION 表（终结符动作）

**构造规则:(看上面的表)**   

> **ACTION[s, a]** 定义了在状态 `s` 下，看到输入符号 `a`（终结符或 `#`）时该做什么。

有三种动作：

- `s j`：**移进**，将 `a` 和状态 `j` 压栈
- `r k`：**归约**，用第 `k` 条产生式归约
- `acc`：**接受**
- 空白：**报错**

### ✅ 构造规则（逐条判断）

对每一个状态 `Ik` 和每一个终结符 `a`（包括 `#`）：

#### 规则 1️⃣：移进（Shift）

如果存在项目 `[A → α • a β] ∈ Ik`，且 `a` 是终结符，  
则设置：
```
ACTION[k, a] = s j
```
其中 `j = GO(Ik, a)`

> 💡 解释：你在等 `a`，现在看到了，就移进，并进入 `GO(Ik, a)` 对应的状态。  

**说人话：**

对于每一个非终止符，**看到他**(小点点在他前面)，那么我们就转到**看到他之后**(小点点移动到他后面)的状态。

**数学模型:** `ACTION[k, a] = GO(Ik, a)`

    S  → • a S    || 移动点 S -> a • S (I2)   || GO(I0, a) = I2

所以 `ACTION[2, a] = 2`

#### 规则 2️⃣：归约（Reduce）

如果存在**归约项目** `[A → α •] ∈ Ik`（即点在末尾），  
且 `A → α` 是文法中的第 `k` 条产生式，  
则对每一个 `a ∈ FOLLOW(A)`，设置：
```
ACTION[k, a] = r k
```

> 💡 解释：你已经完整识别了 `A → α`，只要下一个输入符号 `a` 在 `FOLLOW(A)` 中，就可以归约。

**人话：**

小点点到最后了，那就是可以规约了。  

规约成什么东西呢呢。看下A -> α的文法，它是第k条文法，那么我们就用第k条文法来规约。至于他是第几条，那是我们规定的。

然后是规约式写在谁的头上呢？啊也就是看A的FOLLOW集合，说白了，小点点到最后了，好我们看小点点后面的那个东西进行规约，`那么小点点都到最后了，那tm没东西啊？啊还有个#终止符号`

**数学模型：**

    I3:
    S → b •     

`ACTION[3, #] = r2`

`3`就是当前的状态，`#`(是S的FOLLOW集合元素)， `r2`的2单纯是因为我们文法规定的 S -> b 的编号是2，看最上面的文法。


⚠️ **关键点**：SLR 使用 `FOLLOW(A)` 来决定何时归约，这是它与 LR(1) 的区别。

#### 规则 3️⃣：接受（Accept）

如果存在项目 `[S' → S •] ∈ Ik`，  
则设置：
```
ACTION[k, #] = acc
```

> 💡 这是唯一的接受条件：必须归约到 `S' → S`，且输入结束。

**人话：**

第一条文法，那就是直接acc。

---

我们逐个状态分析：

#### 🔹 状态 I0

- `S → • a S` → `ACTION[0, a] = s2`（移进，进入 I2）
- `S → • b` → `ACTION[0, b] = s3`（移进，进入 I3）

#### 🔹 状态 I1

- `S' → S •` → 归约项目，且是 `S' → S`，表示**接受**
- 所以 `ACTION[1, #] = acc`（# 表示输入结束）

#### 🔹 状态 I2

- `S → • a S` → `ACTION[2, a] = s2`
- `S → • b` → `ACTION[2, b] = s3`

#### 🔹 状态 I3

- `S → b •` → 归约项目，产生式编号 (2)`单纯因为我们规定的S -> b文法的编号是2，看最上面的文法`
- `FOLLOW(S)` 是什么？因为 `S` 是开始符号，`FOLLOW(S) = {#}`
- 所以 `ACTION[3, #] = r2`（用 `S → b` 归约）

#### 🔹 状态 I4

- `S → a S •` → 归约项目，产生式编号 (1)
- `FOLLOW(S) = {#}`
- 所以 `ACTION[4, #] = r1`（用 `S → a S` 归约）

---

### ✅ 最终分析表

| 状态 | ACTION |      | | GOTO |
|------|--------|-------|------|-|
|      | **a**  | **b** | **#** | **S** |
| **0**| s2     | s3    |       | 1     |
| **1**|        |       | acc   |       |
| **2**| s2     | s3    |       | 4     |
| **3**|        |       | r2    |       |
| **4**|        |       | r1    |       |

> 🔑 说明：
- `s2`：移进 `a`，进入状态 2
- `s3`：移进 `b`，进入状态 3
- `r1`：用 `S → a S` 归约
- `r2`：用 `S → b` 归约
- `acc`：接受

---

## 🧪 五、测试：分析输入串 `a a b`

目标：判断 `a a b` 是否合法。

初始：
- 状态栈: `[0]`
- 符号栈: `[#]`
- 输入: `a a b #`

### 🔹 步骤 1：读 `a`

- `ACTION[0, a] = s2`
- 移进，压入状态 2 和符号 `a`

```
状态栈: [0, 2]
符号栈: [# a]
输入: a b #
```

### 🔹 步骤 2：读 `a`

- `ACTION[2, a] = s2`
- 移进

```
状态栈: [0, 2, 2]
符号栈: [# a a]
输入: b #
```

### 🔹 步骤 3：读 `b`

- `ACTION[2, b] = s3`
- 移进

```
状态栈: [0, 2, 2, 3]
符号栈: [# a a b]
输入: #
```

### 🔹 步骤 4：归约 `S → b`

- `ACTION[3, #] = r2`
- 用 `S → b` 归约
- 弹出 1 个状态和符号（`b` 长度为 1）
- 栈顶回到状态 2
- `GOTO[2, S] = 4`
- 压入状态 4 和 `S`

```
状态栈: [0, 2, 4]
符号栈: [# a a S]
输入：#
```

### 🔹 步骤 5：归约 `S → a S`

- `ACTION[4, #] = r1`
- 用 `S → a S` 归约
- 弹出 2 个状态和符号（`a S` 长度为 2）
- 栈顶回到状态 0
- `GOTO[0, S] = 1`
- 压入状态 1 和 `S`

```
状态栈: [0, 1]
符号栈: [# S]
输入：#
```

### 🔹 步骤 6：接受！

- `ACTION[1, #] = acc`
- ✅ 接受！输入串 `a a b` 合法。

---

## 🎯 六、总结：你学到了什么？

| 概念 | 在这个例子中的体现 |
|------|------------------|
| **项目** | `S → a • S` 表示“已经看到 `a`，正在等 `S`” |
| **闭包** | `I2` 中 `S → a • S` 需要展开 `S → • a S` 和 `S → • b` |
| **GO函数** | `GO(I0, a) = I2`，表示读入 `a` 后进入新状态 |
| **活前缀** | `a`, `a a`, `a a b` 都是活前缀 |
| **ACTION表** | 决定移进还是归约 |
| **GOTO表** | 决定归约后进入哪个状态 |

---

这个例子虽然简单，但它完美展示了 LR 分析的核心机制：**用状态机识别活前缀，用表格驱动归约**。

现在你已经掌握了从文法到分析表的完整构造过程！如果你想挑战更复杂的文法（比如带左递归的），我们可以继续深入。你想试试吗？

## 好了现在我们已经搞完了完整构建LR分析表的过程，然后进行语法分析。

## 啊别高兴太早，这只是SLR(1)分析法

| 分析法 | 是否使用 `FOLLOW` | 向前看信息精度 | 冲突处理能力 |
|--------|-------------------|----------------|--------------|
| **LR(0)** | ❌ 不使用 | 无向前看 | 极易冲突 |
| **SLR(1)** | ✅ 使用 `FOLLOW(A)` | 全局粗略 | 减少冲突 |
| **LALR(1)** | ✅ 使用**局部精确向前看集** | 高 | 很少冲突 |
| **LR(1)** | ✅ 每个项目带独立向前看符号 | 最高 | 几乎无冲突 |

---
---
```

```
---
---

# 其他的狗屎概念