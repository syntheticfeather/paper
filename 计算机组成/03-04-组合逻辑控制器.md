
### **学习目标**

1.  理解组合逻辑控制器的基本工作原理。
2.  掌握控制器的三级时序系统（周期、节拍、脉冲）。
3.  学会分析指令的执行流程和操作时间表。
4.  了解组合逻辑控制器的优缺点。

---

### **一、组合逻辑控制器概述**

*   **定义**：微命令（控制信号）由**组合逻辑电路**直接产生。
    *   每一个微命令都需要一组特定的逻辑门电路来生成。
    *   所有微命令的生成电路共同构成了“微命令发生器”。
*   **硬件组成**：
    *   **程序计数器（PC）**：存放下一条指令的地址。
    *   **指令寄存器（IR）**：存放当前正在执行的指令。
    *   **状态寄存器（PSW）**：存放CPU的状态信息（如进位、溢出等）。
    *   **时序系统**：提供时间基准（周期、节拍、脉冲）。
    *   **微命令发生器**：核心，由组合逻辑电路构成，产生所有控制信号。
    *   **译码器**：对指令的操作码和寻址方式码进行译码。
    *   **地址形成部件**：根据寻址方式计算操作数的实际地址。
*   **工作原理**：
    1.  指令从内存读取后存入**IR**。
    2.  IR中的**操作码**和**寻址方式码**被送入**译码器**，产生一些中间逻辑信号。
    3.  这些中间信号，结合**时序信号**（当前处于哪个周期、节拍）和**状态信息**（PSW、中断请求等），作为输入，送入**微命令发生器**。
    4.  **微命令发生器**（组合逻辑电路）根据这些输入，**实时计算**并输出当前时刻需要的所有**微命令**（如“打开A门”、“启动加法器”、“将结果写回寄存器”等）。

> **关键点**：控制信号是“算”出来的，而不是“查”出来的（这与下一章的微程序控制器相反）。

---

### **二、组合逻辑控制器时序系统**

CPU的工作是高度有序的，需要精确的时间控制。本模型机采用了**三级时序**：

1.  **工作周期（Cycle）**：CPU工作的宏观阶段。
    *   **取指周期（FT）**：从内存取指令，PC+1。
    *   **源周期（ST）**：如果需要，从内存读取源操作数。
    *   **目的周期（DT）**：如果需要，从内存读取目的操作数或目的地址。
    *   **执行周期（ET）**：执行指令的核心操作（如加法、存数等），是所有指令的最后一个阶段。
    *   **中断周期（IT）**：响应中断请求，保存现场。
    *   **DMA周期（DMAT）**：响应DMA请求，CPU交出总线控制权。
    *   **特点**：在任一时刻，只有一个周期状态触发器为1，标志着CPU当前所处的阶段。

2.  **时钟周期（节拍，T）**：每个工作周期被划分为若干个时钟周期（节拍）。
    *   本模型机将一个时钟周期的宽度定义为**1微秒**，即一次主存访问所需的时间。
    *   一个工作周期可能包含多个节拍（T0, T1, T2...）。

3.  **工作脉冲（P）**：在每个时钟周期的**末尾**产生一个工作脉冲P。
    *   **P的前沿**：用于**打入寄存器**，将稳定的数据锁存到寄存器中。标志着一个数据通路操作的完成。
    *   **P的后沿**：用于**时序转换**。根据当前周期是否结束，决定是进入下一个节拍（T+1），还是进入下一个工作周期。

> **时序关系**：`工作周期 > 时钟周期（节拍） > 工作脉冲`

---

### **三、指令流程与操作时间表**

这是本章最核心、最实践的部分。它告诉我们CPU是如何一步步执行一条指令的。

#### **1. 取指周期（FT）**

这是所有指令执行的第一步，是**公共操作**。
*   **流程**：`M → IR`（内存数据送指令寄存器），`PC+1 → PC`（程序计数器加1，指向下一条指令）。
*   **操作时间表**（微命令序列）：
    *   `EMAR`（打开PC到MAR的门，PC内容送地址总线）
    *   `R`（内存读命令）
    *   `S_IR`（将内存数据送入IR）
    *   `PC→A`，`A+1`，`DM`，`CP_PC`（PC内容加1）
    *   `1→ST`，`CP_ST`（准备进入下一个可能的周期，这里是ST）

#### **2. 源周期（ST）与目的周期（DT）**

这两个周期用于处理内存操作数。根据寻址方式不同，流程也不同。

*   **以 `(R)+` 寻址为例**（如 `MOV R0, (R1)+`）：
    1.  **ST0**：`R1 → MAR`（寄存器R1内容送地址总线）
    2.  **ST1**：`M → MDR → C`（读内存，数据送入MDR，再送入暂存器C）
    3.  **ST2**：`R1+1 → R1`（R1自增，实现“后递增”）
    4.  **ST3**：`1→DT`（准备进入DT周期）

*   **ST与DT的区别**：
    *   **MOV指令**：在DT中，**不需要**取出目的操作数（因为是写入），所以没有 `M→MDR→D` 这一步。
    *   **双操作数指令**（如ADD）：在DT中，**需要**取出目的操作数（除非是寄存器寻址），所以有 `M→MDR→D` 这一步。

#### **3. 执行周期（ET）**

这是执行指令功能的核心阶段。根据源和目的的寻址方式，ET周期有四种分支：

| 源寻址 | 目的寻址 | 例子 |
| :--- | :--- | :--- |
| 寄存器（SR） | 寄存器（DR） | `ADD R0, R1` |
| 寄存器（SR） | 内存（DR） | `ADD (R0), R1` |
| 内存（SR） | 寄存器（DR） | `ADD R0, (R1)` |
| 内存（SR） | 内存（DR） | `ADD (R0), (R1)` |

*   **以 `MOV (R0)+, R1` 为例**（SR·DR，结果存内存）：
    *   **ET0**：`R1 → MDR`（源操作数送MDR）
    *   **ET1**：`MDR → M`（MDR内容写入内存）
    *   **ET2**：`PC → MAR`（为取下一条指令做准备）
    *   **ET2**：`1→FT`（设置下一周期为取指周期）

#### **4. 其他指令类型**

*   **单操作数指令**（如INC, DEC）：无ST周期，有DT周期（取操作数），ET周期根据结果存寄存器还是内存分两种。
*   **转移指令（JMP）**：无ST、DT周期，ET周期根据条件判断是否跳转。
*   **转子指令（JSR）**：非常关键！在ET周期中，需要**保护现场和断点**。
    *   例如，将返回地址（PC内容）压入堆栈：`SP-1→SP`，`PC→MDR`，`MDR→M`。

---

### **四、组合逻辑控制方式的优缺点**

*   **优点**：
    *   **速度快**：微命令由组合逻辑直接产生，延迟小，执行速度快。这是其最大优势。

*   **缺点**：
    1.  **设计繁琐**：组合逻辑电路形态不规整，设计、调试非常困难。
    2.  **不易修改**：一旦用硬件（印制电路板）实现，很难修改或扩展指令集。增加一条新指令，可能需要重新设计整个控制器。

> **总结**：组合逻辑控制器是一种**硬连线**的控制器，速度快但灵活性差。现代CPU为了兼顾速度和灵活性，通常采用更复杂的**微程序控制器**或**硬布线与微程序结合**的方式。

---
---
---
---

## ST与DT区别

#### 一般第一个为目标操作数，第二个为源操作数。

好的，我们来对 **ST（源周期）** 和 **DT（目的周期）** 的区别进行一次深入、详细的分析。这个问题触及了CPU指令执行流程设计的核心逻辑。

简单来说，它们的区别源于指令中**源操作数（Source Operand）** 和**目的操作数（Destination Operand）** 在执行过程中的**不同角色**和**访问时机**。

---

### **核心区别总结**

| 特性 | 源周期（ST） | 目的周期（DT） |
| :--- | :--- | :--- |
| **目的** | **读取**源操作数，为执行阶段做准备。 | **读取**目的操作数（仅当需要）或**准备目的地址**。 |
| **操作数状态** | 总是需要**读取**（Load）。 | 可能需要**读取**（如ADD），也可能不需要（如MOV）。 |
| **典型指令** | 所有需要从内存取源操作数的指令。 | MOV指令（不需要读目的操作数）<br>双操作数指令如ADD（需要读目的操作数） |
| **核心动作** | `M → MDR → C` (将内存数据送入暂存器C) | 1.  `M → MDR → D` (读目的操作数)<br>2.  或仅准备地址（如MOV） |

---

### **详细分析：为什么会有这个区别？**

这个区别的产生，根本原因在于**指令语义**和**数据流**的不同。

#### **1. 指令语义的差异**

*   **MOV指令**（数据传送）：`MOV 目的操作数, 源操作数`
    *   **语义**：将“源”的值**复制**到“目的”。
    *   **对目的操作数的要求**：我们**不需要知道**目的操作数当前的值是多少，因为我们要用源的值**覆盖**它。
    *   **结论**：在DT周期，**不需要**从内存中读取目的操作数的旧值。只需要计算出目的地址，为后续的“写入”操作做准备。

*   **双操作数算术/逻辑指令**（如ADD, SUB）：`ADD 目的操作数, 源操作数`
    *   **语义**：将“目的”和“源”的值**相加**，结果**存回**目的。
    *   **对目的操作数的要求**：我们必须**知道**目的操作数当前的值，因为它要参与运算。
    *   **结论**：在DT周期，**必须**从内存中读取目的操作数的旧值，将其送入暂存器（如D），然后才能与源操作数进行运算。

## MOV (R0) R1详细步骤

这条指令的意思是：“把寄存器R1中的值，复制到**内存地址为R0的内容**的那个单元中”。

执行流程如下：

1.  **DT周期**：
    *   同样，控制器发出微命令：`R0 → MAR`
        *   将R0中的地址值（如 `0x1000`）送入MAR。
    *   （注意：对于MOV指令，DT周期通常**不需要**从内存读取旧值，所以没有 `M→MDR` 这一步）

2.  **准备写入数据**：
    *   在ET周期，控制器先发出微命令：`R1 → MDR`
        *   将寄存器R1中的数据（比如 `0x1234`）送入MDR。
    *   此时，MDR中存着要写入的数据 `0x1234`，MAR中存着目标地址 `0x1000`。

3.  **启动内存写操作**：
    *   控制器发出微命令：`EMAR`, `W`
        *   `EMAR`：将MAR中的地址 `0x1000` 发送到地址总线上。
        *   `W`：发出“内存写”控制信号。
    *   同时，MDR会将其内容 `0x1234` 驱动到**数据总线**上。

4.  **完成写入**：
    *   内存控制器接收到地址 `0x1000`、“写”信号以及数据总线上的 `0x1234`，就会将 `0x1234` 写入内存地址 `0x1000` 的单元。

> **总结流程**：`R0` (含地址) → `MAR` → 地址总线
>
> `R1` → `MDR` → 数据总线 → 内存单元


|周期|指令|操作|
|----|-|-|
|FT|M → IR|将内存数据送入指令寄存器|
||PC+1 → PC|程序计数器加1，指向下一条指令|
|ST|无|无|
|DT|R0 → MAR|准备地址|
|ET|R1 → MDR|源操作数送入MDR|
||MDR → M|目的地址写入内存|
||PC → MAR|为取下一条指令做准备|

## MOV R1 (R0)详解

这条指令的意思是：“把**内存地址为R0的内容**的那个单元中的值，复制到寄存器R1中”。

执行流程如下：

1.  **ST周期开始**：
    *   控制器发出微命令：`R0 → MAR`
        *   **动作**：将寄存器R0中的**数值**（这个数值是一个内存地址，比如 `0x1000`）送到MAR。
        *   **结果**：MAR现在存着 `0x1000`。

2.  **启动内存读操作**：
    *   控制器发出微命令：`EMAR`, `R`
        *   `EMAR`：打开MAR到地址总线的门，将MAR中的地址 `0x1000` 发送到地址总线上。
        *   `R`：发出“内存读”控制信号。
    *   内存控制器接收到地址 `0x1000` 和“读”信号后，会将该地址单元的内容（比如 `0xABCD`）放到**数据总线**上。

3.  **接收数据**：
    *   控制器发出微命令：`S_MDR`
        *   `S_MDR`：将数据总线上的数据 `0xABCD` **锁存**到MDR中。
    *   此时，MDR中存着从内存读出的数据 `0xABCD`。

4.  **ET周期（执行并传送）**：
    *   控制器发出微命令：`MDR → B`, `B → A/B`, `DM`, `CP_R1`
        *   将MDR中的数据 `0xABCD` 送入运算器的输入端口。
        *   打开数据总线。
        *   将数据总线上的值打入寄存器R1。
    *   最终，R1的值变成了 `0xABCD`。

> **总结流程**：`R0` (含地址) → `MAR` → 地址总线 → 内存单元 → 数据总线 → `MDR` → CPU内部数据通路 → `R1`

|周期|指令|操作|
|----|-|-|
|FT|M → IR|将内存数据送入指令寄存器|
||PC+1 → PC|程序计数器加1，指向下一条指令|
|ST|R0 -> MAR|R0中的数值送入MAR|
||M -> MDR -> C|将内存数据送入暂存器C|
|DT|无|无|
|ET|C -> R1 |C中的数值送入R1|
|   |PC -> MAR|为取下一条指令做准备|

## ADD R0 -(R1)

|周期|指令|操作|
|----|-|-|
|FT|M → IR|将内存数据送入指令寄存器|
|| PC + 1 → PC|程序计数器加1，指向下一条指令|
|ST|R1 - 1 -> R1, MAR||R1自减1，地址送MAR|
||M → MDR -> C|将内存数据送入暂存器C|
|DT|无|无|
|ET|R0 + C → R0, MAR|C中的数值送入R0，地址送MAR|

## ADD R0, X(R1)

### **1. X(R) 寻址方式**

#### **概念解析**

*   **格式**：`X(R)`，例如 `X(R1)`
*   **语义**：操作数在内存中，其**有效地址（Effective Address, EA）** = `X + (R)`。
    *   `X`：**位移量（Displacement）**，一个立即数，通常紧跟在主指令字之后存放在内存中。
    *   `(R)`：**基址寄存器（Base Register）**，R中的内容是基地址。
*   **特点**：`X` 是静态的（在编译时确定），`R` 是动态的（运行时变化）。常用于访问**数组的某个固定偏移元素**。

#### **ADD 指令示例：`ADD R0, X(R1)`**

*   **语义**：
    1.  从内存中读取位移量 `X`。
    2.  计算有效地址 `EA = X + R1`。
    3.  从地址 `EA` 处读取操作数。
    4.  将 `R0` 的值与此操作数相加，结果存回 `R0`。
    *   即：`R0 ← R0 + Memory[X + R1]`

#### **执行步骤**

| 周期 | 时序信号 | 指令流程 | 电平型微命令 | 脉冲型微命令 |
| :--- | :--- | :--- | :--- | :--- |
| **FT** | FT0 | M → IR | EMAR, R | S_IR |
| | | PC+1 → PC | PC→A, A+1, DM | CPPC, CPT |
| | FT1 | (准备下一周期) | | **CPST** |
| **ST** | ST0 | **PC → MAR** | **PC→A**, A, DM | **CPMAR**, CPT |
| | ST1 | **M → MDR → C** | **EMAR, R** | **S_MDR, CPC**, CPT |
| | ST2 | **PC+1 → PC** | PC→A, A+1, DM | CPPC, CPT |
| | ST3 | **R1 + C → MAR** | R1→A/B, C→B/A, A+B, DM | CPMAR, CPT |
| | ST4 | **M → MDR → C** | EMAR, R | S_MDR, CPC, CPT |
| **DT** | | 无 | | |
| **ET** | ET0 | **R0 + C → R0** | R0→A/B, C→B/A, A+B, DM | CPR0, CPT |
| | ET1 | **PC → MAR** | PC→A, A, DM | CPMAR, CPFT |

> **关键点**：
>
> *   **ST0-ST1**：读取位移量 `X`（存入C）。
> *   **ST2**：PC再加1，指向下一条指令。
> *   **ST3**：计算 `EA = R1 + X`，结果送入MAR。
> *   **ST4**：从 `EA` 处读取真正的操作数（存入C）。
> *   **ET0**：执行 `R0 + C → R0`。


## ADD R0, @(R1)

### **2. @(R) 寻址方式**

#### **概念解析**

*   **格式**：`@(R)`，例如 `@(R1)`。在您提供的PDF中，这被称为“**寄存器间址**”。
*   **语义**：操作数在内存中，其地址是一个**指针**，该指针的值存储在寄存器 `R` 中。
    1.  先从 `R` 中取出一个值，这个值**本身是一个内存地址**（我们称它为**指针地址**）。
    2.  然后，以这个地址为**指针**，去访问它所指向的**目标内存单元**，该单元中的内容才是真正的操作数。
*   **特点**：这是一种**间接寻址**，可以实现动态访问。常用于实现**指针**、**函数调用**等。

#### **ADD 指令示例：`ADD R0, @(R1)`**

*   **语义**：
    1.  以 `R1` 的内容作为地址，从内存中读取一个**指针值**（假设为 `Addr`）。
    2.  再以 `Addr` 作为地址，从内存中读取真正的操作数。
    3.  将 `R0` 的值与此操作数相加，结果存回 `R0`。
    *   即：`R0 ← R0 + Memory[Memory[R1]]`

#### **执行步骤**

| 周期 | 时序信号 | 指令流程 | 电平型微命令 | 脉冲型微命令 |
| :--- | :--- | :--- | :--- | :--- |
| **FT** | FT0 | M → IR | EMAR, R | S_IR |
| | | PC+1 → PC | PC→A, A+1, DM | CPPC, CPT |
| | FT1 | (准备下一周期) | | **CPST** |
| **ST** | ST0 | **R1 → MAR** | **R1→A/B**, A/B, DM | **CPMAR**, CPT |
| | ST1 | **M → MDR → C** | **EMAR, R** | **S_MDR, CPC**, CPT |
| | ST2 | **C → MAR** | **C→A/B**, A/B, DM | **CPMAR**, CPT |
| | ST3 | **M → MDR → C** | **EMAR, R** | **S_MDR, CPC**, CPT |
| **DT** | | 无 | | |
| **ET** | ET0 | **R0 + C → R0** | R0→A/B, C→B/A, A+B, DM | CPR0, CPT |
| | ET1 | **PC → MAR** | PC→A, A, DM | CPMAR, CPFT |

> **关键点**：
>
> *   **ST0**：将 `R1` 的内容（指针地址）送入MAR。
> *   **ST1**：从指针地址处读取**目标地址** `Addr`，存入C。
> *   **ST2**：将C中的 `Addr` 送入MAR。
> *   **ST3**：从 `Addr` 处读取真正的操作数（存入C）。
> *   **ET0**：执行 `R0 + C → R0`。

---