前端（Front End）：负责理解源代码。

    词法分析：把字符流变成单词流。

    语法分析：把单词流组合成语法树。

    语义分析：检查这句话有没有“道理”。

后端（Back End）：负责生成目标代码。

    中间代码生成：生成一种抽象、简单的指令。

    优化：让代码变得更快、更小。

    代码生成：生成最终的机器码或汇编代码。


# 词法分析
## 把字符流变成单词流。

    核心概念：Token 和 Lexeme
    
        词法单元 (Token)：一个分类或类型。它是一类单词的抽象表示。

        例如：IDENTIFIER（标识符）, KEYWORD（关键字）, LITERAL_INTEGER（整型字面量）, OPERATOR（操作符）.

        词素 (Lexeme)：构成一个Token的具体字符序列。

        例如：对于IDENTIFIER这个Token，它的词素可能是 "result", "a", "count"等。

        比喻：Token就像是“水果”这个类别，而Lexeme则是具体的“苹果”、“香蕉”、“橘子”。

用正则表达式来进行分析

实践:
    用flex写点东西
    lexer.l
    main.c

    编译并链接
    然后运行


    指令:
    # 1. 生成lex.yy.c
    flex lexer.l

    2. 编译词法分析器源文件，生成目标文件lex.yy.o
    gcc -c lex.yy.c

    3. 编译主程序源文件，生成目标文件main.o
    gcc -c main.c

    4. 将两个目标文件链接在一起，生成最终的可执行程序
    gcc lex.yy.o main.o -o my_compiler

flex lexer.l  
gcc -c lex.yy.c  
gcc -c main.c  
gcc lex.yy.o main.o -o my_compiler  

# 语法分析
## 从单词到句子

问题:词法分析器告诉我们“这里有一个关键字if，那里有一个标识符count”。但它无法告诉我们这些单词组合在一起是否构成一个合法的if语句。

语法分析器（Parser）就是做这个的。  
它接收来自词法分析器的Token流，根据预定义的语法规则（Grammar），检查这些Token的排列是否符合规则，并最终生成一棵语法树（Syntax Tree）。

    核心概念：上下文无关文法（Context-Free Grammar, CFG）
    
    终结符（Terminals）： 就是词法分析产生的Token（如 IDENTIFIER, +, IF）。它们是语法树的叶子节点。

    非终结符（Non-terminals）： 代表语法结构的名字（如 statement, expression, if_statement）。它们是语法树的内部节点。

    产生式（Productions）： 定义语法规则的公式。形式为：非终结符 -> 序列（可由终结符和非终结符组成）。

    开始符号（Start Symbol）： 最顶层的非终结符，通常代表一个完整的程序（如 program）。