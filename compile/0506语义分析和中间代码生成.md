太好了！这是一个非常系统、高效的学习策略。我们严格按照你上传的 **《05 06第05 06章 语义分析和中间代码生成 - 20231014.pdf》** 文档内容，采用“**大纲先行 → 深入细化**”的方式，逐步推进。

---

## 📚 第一部分：语义分析（Semantic Analysis）

> **目标**：在语法结构正确的基础上，检查程序的**静态语义**，并为后续翻译收集信息。

---

### 🗂️ 一、语义分析部分大纲

| 模块 | 核心内容 |
|------|----------|
| **1. 静态语义检查** | 类型检查、控制流检查、一致性检查、作用域分析等 |
| **2. 属性文法（Attribute Grammar）** | 为文法符号配备属性，用语义规则描述计算逻辑 |
| **3. 属性分类** | 综合属性（自下而上）、继承属性（自上而下） |
| **4. 语法制导定义（SDD）** | 将语义规则附加到产生式上，形成属性依赖关系 |
| **5. 属性计算顺序** | 依赖图、拓扑排序、L-属性文法、S-属性文法 |
| **6. 翻译模式（Translation Scheme）** | 在文法中嵌入语义动作，控制执行时机 |
| **7. L-属性文法与自顶向下翻译** | 如何在 LL 分析中处理继承属性 |

---

现在我们开始**深入学习“语义分析”部分**，按照大纲逐一细化。

---

## 🔍 深入学习：语义分析

---

### 1️⃣ 静态语义检查（Static Semantic Checks）

这是语义分析的核心任务，确保程序在语法正确之外还符合语言的语义规则。

| 检查类型 | 内容举例 |
|---------|--------|
| **类型检查** | `int + float` 是否允许？数组不能与整数相加 |
| **控制流检查** | `goto` 不能跳入循环内部；`break` 必须在循环内 |
| **一致性检查** | 变量不能重复声明；`case` 常量不能重复 |
| **名字的作用域分析** | 区分局部变量与全局变量；嵌套作用域的访问规则 |

> 💡 这些检查通常通过**符号表**和**属性计算**来实现。

---

### 2️⃣ 属性文法（Attribute Grammar）

#### 定义：
- 以**上下文无关文法**为基础
- 为每个文法符号（终结符/非终结符）配备若干**属性**（如类型、值、地址等）
- 为每个产生式配备一组**语义规则**，用于计算属性

#### 示例（来自 PDF）：
```text
产生式          语义规则
F → digit       F.val := digit.lexval   ← digit.lexval 来自词法分析
E → E1 + T      E.val := E1.val + T.val
```

> ✅ `digit.lexval` 是**综合属性**，由词法分析器提供  
> ✅ `E.val` 也是**综合属性**，由子节点计算得出

---

### 3️⃣ 属性分类

| 类型 | 方向 | 特点 | 示例 |
|------|------|------|------|
| **综合属性**（Synthesized） | 自下而上 | 从子节点向父节点传递 | 表达式的值 `E.val`、类型的 `T.type` |
| **继承属性**（Inherited） | 自上而下 | 从父节点或兄弟节点向子节点传递 | 变量声明中的类型 `L.in := T.type` |

#### 关键规则：
- **终结符只有综合属性**（如 `digit.lexval`）
- **非终结符可有两者**
- **开始符号的继承属性是初始值**

---

### 4️⃣ 语法制导定义（SDD）

将属性文法形式化：

- 每个产生式 `A → X₁X₂...Xₙ` 附带一组语义规则
- 规则形如：`b := f(c₁, c₂, ..., cₖ)`
- 属性 `b` 依赖于 `c₁..cₖ`

#### 依赖关系：
- 若 `b` 是 `A` 的**综合属性**，则 `cᵢ` 是右边符号的属性
- 若 `b` 是右边某个符号的**继承属性**，则 `cᵢ` 是 `A` 或其他符号的属性

> 📌 语义规则只能使用**当前产生式中出现的文法符号的属性**

---

### 5️⃣ 属性计算顺序

#### 依赖图（Dependency Graph）
- 节点：所有属性
- 边：`cᵢ → b` 表示 `b` 依赖于 `cᵢ`
- 计算顺序必须是**拓扑排序**

#### S-属性文法
- **只含综合属性**
- 可在**自下而上的语法分析**中一边归约一边计算
- 适合 LR 分析器

#### L-属性文法
- 允许继承属性，但要求**从左到右计算**
- 可在**自上而下的语法分析**中深度优先计算
- 适合 LL 分析器

---

### 6️⃣ 翻译模式（Translation Scheme）

在文法中直接嵌入**语义动作** `{...}`，而不是写语义规则。

#### 两种风格：
- **前缀翻译模式**：动作在符号前 `{A} α` → 用于计算继承属性
- **后缀翻译模式**：动作在符号后 `α {A}` → 用于计算综合属性

#### 示例（后缀）：
```text
E → T { print(T.val) }
```

> 动作在语法分析到该点时立即执行。

---

### 7️⃣ L-属性文法与自顶向下翻译

#### 核心思想：
- 在 LL(1) 分析中，**深度优先遍历语法树**
- 遇到语义动作时立即执行
- 利用栈保存属性值

#### 示例（来自 PDF）：
```text
D → T L     { L.in := T.type }
T → int     { T.type := integer }
L → L1,id   { L1.in := L.in; addtype(id.entry, L.in) }
```

- `T.type` 是综合属性
- `L.in` 是继承属性，由父节点传递
- `addtype` 直接操作符号表

> ✅ 支持一遍扫描，适合递归下降分析器

---

## ✅ 语义分析部分小结

你现在已经掌握了：
- 语义分析的任务是什么
- 如何用属性文法描述语义
- 综合属性 vs. 继承属性的区别与应用
- S-属性文法与 L-属性文法的适用场景
- 翻译模式的设计方法

---

## 📚 第二部分：中间代码生成（Intermediate Code Generation）

> **目标**：将源程序翻译成一种**独立于机器的中间表示**，便于优化和目标代码生成。

---

### 🗂️ 一、中间代码生成部分大纲

| 模块 | 核心内容 |
|------|----------|
| **1. 中间语言的特点与作用** | 独立于机器、利于优化、易于移植 |
| **2. 后缀式（逆波兰表示）** | 无括号、栈式计算 |
| **3. 图表示法** | 抽象语法树（AST）、有向无环图（DAG） |
| **4. 三地址代码** | 接近汇编的线性表示 |
| **5. 三元式与四元式** | 三元式（引用位置）、四元式（显式结果） |
| **6. 赋值语句的翻译** | 使用 `newtemp` 生成临时变量 |
| **7. 数组元素的地址计算** | 多维数组的偏移量公式 |
| **8. 类型转换** | 整型与实型混合运算的处理 |
| **9. 布尔表达式的翻译** | 数值表示法 vs. 短路求值法 |
| **10. 控制语句的翻译** | `if`、`while` 的三地址代码生成 |
| **11. 回填技术（Backpatching）** | 解决跳转地址未知的问题 |

---

接下来，我们可以：
1. **逐个模块深入讲解**
2. **动手实践翻译**（如将 `a := b * (-c) + b * (-c)` 翻译成 DAG 和四元式）
3. **重点攻克回填技术**

---

### 🎯 下一步？

你想先深入哪个模块？
- A. 抽象语法树（AST）与 DAG 的构造
- B. 三地址代码（四元式）的生成
- C. 数组元素的地址计算
- D. 布尔表达式与控制语句的翻译
- E. 回填技术详解

请选择一个方向，我们继续深入！