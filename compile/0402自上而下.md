太好了！让我们进入第四章(02) **自上而下的语法分析**的学习。这是语法分析中非常重要且实用的方法。

---

## 🎯 第四章(02)：自上而下的语法分析

### **一、基本概念**

#### **什么是自上而下分析？**
- **从根到叶**：从文法的开始符号出发，逐步推导出输入串
- **最左推导**：总是扩展最左边的非终结符
- **目标**：为输入串找到一个最左推导序列

#### **核心思想**
```
开始符号 → 推导 → 推导 → ... → 输入串
    ↓        ↓        ↓           ↓
   根节点 → 内部节点 → ... → 叶子节点
```

### **二、自上而下分析示例**

#### **给定文法**
```
G(S):
(1) S → xAy
(2) A → ** | *
```

#### **分析输入串** `x*y`
```
步骤1: S ⇒ xAy        (使用产生式1)
步骤2:   ⇒ x*y        (使用产生式2的第二个候选：A → *)
        ✓ 匹配成功！
```

但如果错误选择：
```
步骤1: S ⇒ xAy        (使用产生式1)  
步骤2:   ⇒ x**y       (使用产生式2的第一个候选：A → **)
         ✗ 与输入串"x*y"不匹配！需要回溯
```

### **三、自上而下分析面临的问题**

#### **问题1：回溯问题**
- **原因**：当非终结符有多个候选式时，选错就要退回重选
- **影响**：效率低下，最坏情况下是指数级时间复杂度

#### **问题2：左递归问题**
**直接左递归示例**：
```
E → E + T | T
```
分析过程：`E ⇒ E + T ⇒ E + T + T ⇒ ...` 无限循环！

### **四、解决方案**

#### **1. 消除左递归**

其实就是换个表达形式，左递归变成了右递归。

**直接左递归消除公式**：
```
A → Aα | β   改为  A → βA'
               A' → αA' | ε
```

**示例**（消除算术表达式的左递归）：
```
原文法：
E → E + T | T
T → T * F | F  
F → ( E ) | i

消除后：
E → TE'
E' → +TE' | ε
T → FT'  
T' → *FT' | ε
F → ( E ) | i
```

---

**间接消除**
```
带循环的语法
S -> Qc|c
Q -> Rb|b
R -> Sa|a

从一个开始，带入其他的式子，消除循环
Q -> Sab|ab|b
S -> Sabc|abc|bc|c
变为一个直接的左递归可以消除的式子

S -> abcS'|bcS'|cS'
S' -> abcS'|ε
```



#### **2. 消除回溯**

**关键条件**：对文法的任何非终结符，当它要去匹配输入串时，能够根据当前输入符号准确选择一个候选式。

**必要条件**：
```
对于 A → α₁ | α₂ | ... | αₙ
要求 FIRST(αᵢ) ∩ FIRST(αⱼ) = ∅ (i ≠ j)
```

#### **3. 提取左因子**
```
A → αβ₁ | αβ₂ | ... | αβₙ | γ₁ | γ₂ | ... | γₘ
改为：
A → αA' | γ₁ | γ₂ | ... | γₘ
A' → β₁ | β₂ | ... | βₙ
```

### **五、FIRST集和FOLLOW集**

#### **FIRST(α)**
- **定义**：α能推导出的**第一个终结符**的集合
- **计算规则**：
  1. 如果X是终结符，FIRST(X) = {X}
  2. 如果X → ε，则ε ∈ FIRST(X)
  3. 如果X → Y₁Y₂...Yₖ，则FIRST(Y₁) ⊆ FIRST(X)

#### **FOLLOW(A)**
- **定义**：可能**紧跟在A后面**的终结符集合
- **计算规则**：
  1. 文法的开始符号S，$ ∈ FOLLOW(S)
  2. 如果A → αBβ，则FIRST(β)-{ε} ⊆ FOLLOW(B)
  3. 如果A → αB 或 A → αBβ且β ⇒* ε，则FOLLOW(A) ⊆ FOLLOW(B)

### **六、LL(1)文法**

**即一种解决了左递归，并且可以做到无回溯的自上而下分析法**

#### **LL(1)条件**
1. 文法不含左递归
2. 对每个非终结符A的各个候选式：FIRST(αᵢ) ∩ FIRST(αⱼ) = ∅
3. 对每个非终结符A，如果它的某个候选式能推出ε，则：  
   FIRST(αᵢ) ∩ FOLLOW(A) = ∅

**LL(1)的含义**：
- **L**：从左向右扫描输入
- **L**：最左推导
- **(1)**：向前看1个符号

### **七、递归下降分析**

#### **基本思想**
- 每个非终结符对应一个分析函数
- 函数体内根据当前输入符号选择候选式
- 通过函数调用实现推导过程

#### **示例**（基于消除左递归后的表达式文法）：
```c
void E() {
    T(); E_prime();
}

void E_prime() {
    if (lookahead == '+') {
        match('+'); T(); E_prime();
    }
    // else: ε，什么都不做
}

void T() {
    F(); T_prime();
}

void T_prime() {
    if (lookahead == '*') {
        match('*'); F(); T_prime();
    }
    // else: ε
}

void F() {
    if (lookahead == '(') {
        match('('); E(); match(')');
    } else if (lookahead == ID) {
        match(ID);
    } else {
        error();
    }
}
```

### **八、预测分析（LL(1)分析）**

#### **预测分析表**
- 二维表M[A, a]，A是非终结符，a是终结符或$
- 表项M[A, a]指示当A在栈顶且输入为a时应使用的产生式

#### **构造算法**
对每个产生式A → α：
1. 对每个a ∈ FIRST(α)，把A → α加入M[A, a]
2. 如果ε ∈ FIRST(α)，对每个b ∈ FOLLOW(A)，把A → α加入M[A, b]

#### **分析过程**
使用栈结构：
1. 初始：栈底为$，栈顶为开始符号
2. 根据栈顶符号X和输入符号a：
   - 如果X = a = $：成功
   - 如果X = a ≠ $：弹出X，读下一个输入
   - 如果X是非终结符：查表M[X, a]，用产生式右部替换X

### **九、计算思维体现**

#### **知识与控制分离**
- **知识**：文法规则（存储在分析表中）
- **控制**：分析算法（独立于具体文法）

#### **自动化**
- 从文法自动构造分析表
- 通用的分析驱动程序

---

# 来点实例

## 📚 实例练习

### **实例1：消除左递归**

**原文法**：
```
E → E + T | T
T → T * F | F
F → ( E ) | id
```

**任务**：消除左递归

**分析操作:**

E -> E + T | T    
就是一串 +  
T -> T * F | F    
就是一串 *  
F -> ( E ) | id    

就是说乘法中既可能是完整的式子，也可能就是一个ID

左递归只需改变前两个式子  
```
E -> TE'  
E' -> + TE' | ε

T -> FT'  
T' -> * FT' | ε

F -> ( E ) | id
```
---

### **实例2：计算FIRST和FOLLOW集**

**文法**（已消除左递归）：
```
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → ( E ) | id
```

**任务**：计算所有非终结符的FIRST和FOLLOW集

**分析操作**

First集合就是能推导出来的所有终结符

Follow集合就是紧跟其后的终止符

**First**

* E

E -> T E'  


所以    ${(, id} \in First(E)$

* T 

First(T) = {(, id}

* E'

E' -> + T E' | ε

First(E') = {+, ε}

* T' 

First(T') = {*, ε}

* F 

First(F) = {(, id}

| 元素名 | 分析过程                         | First集合  |
|--------|----------------------------------|------------|
| E      | E -> T E'                        | {(, id}    |
| T      | T -> F T'                        | {(, id}    |
| E'     | E' -> + T E' \| ε                | {+, ε}     |
| T'     | T' -> * F T' \| ε                | {*, ε}     |
| F      | F -> ( E ) \| id                 | {(, id}    |


**Follow**

* E

        开始符
        Follow(E) = {$}

        F -> ( E ) | id  
        Follow(E) = {$, )}

* T

        E -> T E'  
        E' 可以等于 ε  
        所以 Follow(E) ∈ Follow(T)

        其次 First(E') - {ε} ∈ Follow(T)  
        Follow(T) = {$, +, )}

* E'

        E -> T E'  
        所以 Follow(E) ∈ Follow(E')

        F -> ( T E' ) | id  
        所以 ) ∈ Follow(E')  
        Follow(E') = {$, )}

* T'

        T -> F T'  
        所以 Follow(T) ∈ Follow(T')  
        T' -> * F T' | ε  
        Follow(T') = {$, +, )}

* F

        T' -> * F T' | ε  
        First(T') - {ε} ∈ Follow(F)          
        T -> F T', T' = ε  
        Follow(T) ∈ Follow(F)  
        所以 Follow(F) = {$, +, *, )}


| 元素名 | 分析过程                         | Follow集合 |
|--------|----------------------------------|------------|
| E      | 开始符；E -> T E'                | {$, )}        |
| T      | E -> T E'；E' 可以等于 ε；E' -> + T E' | {$, +, )}  |
| E'     | E -> T E'；T -> F T'             | {$, )}      |
| T'     | T -> F T'；E -> T E'；E' 可以等于 ε；E' -> + T E' | {$, +, )}  |
| F      | F -> ( E ) \| id；T' -> * F T'；E' -> + T E' | {$, *, +, )} |



---

### **实例3：判断LL(1)文法**

**文法**：
```
S → a A b | b A a
A → a | b | ε
```

**任务**：
1. 计算FIRST和FOLLOW集
2. 判断是否为LL(1)文法
3. 如果不是，如何修改使其成为LL(1)文法

**分析操作:**

**先计算First和Follow集:**

* FIRST(S) = {a, b}
理由：S → a A b的第一个符号是a，S → b A a的第一个符号是b。

* FIRST(A) = {a, b, ε}
理由：A → a、A → b、A → ε。

* FOLLOW(S) = {$}
理由：S是开始符号。

* FOLLOW(A) = {a, b}
理由：从S → a A b，所以b在FOLLOW(A)中；从S → b A a，所以a在FOLLOW(A)中。

---

**LL(1)判断条件:**

* 无左递归：✓ 文法没有左递归。

* 产生式的FIRST集不相交：

    对于S：FIRST(a A b) = {a}，FIRST(b A a) = {b}，不相交。✓

    对于A：FIRST(a) = {a}，FIRST(b) = {b}，FIRST(ε) = {ε}，不相交。✓

* 如果有ε产生式，则FIRST(A) ∩ FOLLOW(A) = ∅：

    A有ε产生式，FIRST(A) = {a, b, ε}，FOLLOW(A) = {a, b}，所以FIRST(A) ∩ FOLLOW(A) = {a, b} ≠ ∅。✗


---

### **实例4：综合问题**

**原文法**：
```
S → A a | B b
A → A c | S d | ε
B → B e | f
```

**任务**：
1. 消除左递归
2. 提取左因子（如果需要）
3. 计算FIRST和FOLLOW集
4. 判断是否为LL(1)文法

**分析操作:**

把上面的几步全部来一遍


---

**提示**：
- 对于消除左递归，记住公式：`A → Aα | β` 改为 `A → βA'` 和 `A' → αA' | ε`
- 对于FIRST集：考虑每个产生式右部的第一个符号
- 对于FOLLOW集：考虑每个非终结符后面可能出现的符号
- 对于LL(1)判断：检查三个条件是否满足


## 💡 关键洞察

1. **自上而下分析直观但有限制**：必须处理左递归和回溯问题
2. **LL(1)文法是"好用的"文法**：可以无回溯地预测分析
3. **递归下降易于理解实现**：适合手工编写语法分析器
4. **预测分析更通用高效**：适合自动生成的分析器

**思考题**：
- 为什么大多数编程语言文法不是LL(1)的？

    **主要原因**：
    1. **运算符优先级**：LL(1)文法需要显式编码优先级，导致文法复杂
    ```
    // 在LL(1)中需要这样表达优先级
    expr → term expr'
    expr' → + term expr' | ε
    term → factor term' 
    term' → * factor term' | ε
    ```

    2. **公共前缀问题**：很多语法结构有相同的前缀
    ```
    // 函数调用和数组访问有相同前缀
    primary → id ( expr_list )     // 函数调用
            | id [ expr ]          // 数组访问
            | id                   // 简单变量
    ```
    它们的FIRST集相交，不满足LL(1)条件

    3. **悬空else问题**：if-else语句的二义性难以在LL(1)中优雅处理

- 如何处理if-else语句的悬空else问题？

    **在LL(1)中的解决方案**：

    #### **方法1：文法重写**
    ```
    stmt → matched_stmt | open_stmt
    matched_stmt → if ( expr ) matched_stmt else matched_stmt
                | other_statement
    open_stmt → if ( expr ) stmt
            | if ( expr ) matched_stmt else open_stmt
    ```
    这样强制else与最近的if匹配，但文法变得复杂。

    #### **方法2：预测分析表特殊处理**
    在构造预测分析表时，当遇到：
    ```
    stmt → if ( expr ) stmt
    stmt → if ( expr ) stmt else stmt
    ```
    对于输入符号`else`，选择第二个产生式（带else的）。

    #### **方法3：递归下降中的特殊逻辑**
    ```c
    void parse_stmt() {
        if (lookahead == IF) {
            match(IF); match('('); parse_expr(); match(')');
            parse_stmt();
            if (lookahead == ELSE) {  // 前瞻判断
                match(ELSE);
                parse_stmt();
            }
        } else {
            // 处理其他语句
        }
    }
    ```

    **实际编译器中的做法**：通常使用方法3，因为它最简单直观，虽然严格来说破坏了纯LL(1)的性质。

