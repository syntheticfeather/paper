# Task1 词法分析实验

## 目录

    task1
        |--实验1课件     // 顾名思义课件
        |-- answers     // 直接CV的答案        
        |-- task.l      // Flex 文件
        |-- task2.l     // Flex 文件，用于其他测试用例
        |-- test.c      // 存放测试案例和预期输出
        |-- token.h     // 必要的头文件

# 词法分析要干什么？

## 一、什么是词法分析？

词法分析是编译过程的第一阶段。它的任务是：

> **将源代码的字符流转换成有意义的“记号”（Token）序列。**

例如，对于下面这行 C 语言代码：

```c
int x = 10 + y;
```

词法分析器会将其分解为如下 Token 序列：

```
<KEYWORD, "int">
<IDENTIFIER, "x">
<OPERATOR, "=">
<INTEGER, "10">
<OPERATOR, "+">
<IDENTIFIER, "y">
<SEMICOLON, ";">
```

这些 Token 将作为下一层——**语法分析器**（Parser）的输入。

### 所以我们要干什么？？？？？

**写正则表达式匹配，然后输出对应的枚举值。**

---

## 二、什么是 Flex？

`Flex`（Fast Lexical Analyzer Generator）是一个**词法分析器生成工具**。它不是直接写词法分析代码，而是：

> **你用一种规则语言描述“什么样的字符序列对应什么 Token”，Flex 自动生成 C 代码来实现这个分析器。**

它的输入文件通常是 `.l` 结尾，比如 `lexer.l`。

---

### Flex环境配置

* exe文件安装，bin目录添加到环境变量

* 命令行 `flex --version` 验证是否成功

---

### Flex的xxx.l文件

一个典型的 Flex 文件分为三个部分，用 `%%` 分隔：

```flex
%{
    // C 代码声明区（可选）
    // 通常放头文件、全局变量、函数声明等
%}

/* 想不到吧这里面的注释是这个样子的 */

%%

/* 规则区（核心） */
模式1    { 动作1 }
模式2    { 动作2 }
...

%%

// 用户子程序区（可选）
// 可以写额外的 C 函数
```

---

### 四、核心：规则区（Rules Section）

这是你最需要关注的部分。每条规则是：

```
正则表达式    { C 代码动作 }
```

当输入流匹配某个正则表达式时，就执行对应的 C 代码。

#### 示例：简单词法分析器 `lexer.l`

```flex
%{
#include <stdio.h>
#include "y.tab.h"  // 如果和 Yacc/Bison 配合使用
%}

%%

int         { printf("KEYWORD: int\n"); return INT; }
void        { printf("KEYWORD: void\n"); return VOID; }
[a-zA-Z_][a-zA-Z0-9_]*   { printf("IDENTIFIER: %s\n", yytext); return ID; }
[0-9]+      { printf("NUMBER: %s\n", yytext); return NUM; }
"="         { printf("ASSIGN\n"); return '='; }
"+"         { printf("PLUS\n"); return '+'; }
"-"         { printf("MINUS\n"); return '-'; }
"*"         { printf("MULT\n"); return '*'; }
"/"         { printf("DIV\n"); return '/'; }
[ \t\n]     ; // 忽略空白字符
.           { printf("UNKNOWN: %s\n", yytext); }

%%

int yywrap() {
    return 1;
}
```

#### 实例：复杂的词法分析器(去看task.l)

---

#### 关键变量和函数说明：

- `yytext`：当前匹配到的字符串（char* 类型）。
- `yyleng`：匹配字符串的长度。
- `yyin`：输入文件指针（默认是 stdin）。
- `yywrap()`：当文件读完时调用，返回 1 表示结束，0 表示继续读下一个文件（通常简单实现返回 1 即可）。

---

### 五、Flex 的工作流程

1. 你编写 `.l` 文件。
2. 运行 `flex lexer.l` → 生成 `lex.yy.c`（一个 C 程序）。
3. 编译：`gcc lex.yy.c -o lexer`。
4. 运行：`./lexer`，它会从标准输入读取内容并输出 Token。

---

### 六、指令运行

```bash
# 首先进入目录
cd compile/practice/task1

# 编译
flex task.l
gcc -o a lex.yy.c -I.
./a.exe
```

### 七、答案

answers里面的文件加上你的实验报告一起丢过去

## Flex细节

那么首先，我们清楚Flex会生成一个.c文件。那么C文件能运行必然有main函数。

### lex.yy.c的默认main函数

```c
// 1772行
int main(){
    yylex();
    return 0;
}
```

### main里面是什么呢？

啊这就是一个大型if-else语句

但是根据你写的.l文件会变成不同的if-else语句

每一个if里面就是我们在规则区定义的c语言

不过我们覆写，没他事。

那么可以看到`yylex()`函数还是没有定义。再找找

```c
int main(int argc, char **argv)
{
    int token;
    while ((token = yylex()) != 0)
    {
        if (token <= 260)
        {
            switch (token)
            {
            case Y_ID:
                printf("<%d, %s>\n", token, yylval.id_name);
                free(yylval.id_name);
                break;
            case num_INT:
                printf("<%d, %d>\n", token, yylval.int_value);
                break;
            case num_FLOAT:
                printf("<%d, %f>\n", token, yylval.float_value);
                break;
            default:
                printf("<UNKNOWN>\n");
                break;
            }
        }
        else
        {
            if (token <= 269 || token == 293)
            {
                char words[10] = "KEYWORD";
                printf("<%d, %s>\n", token, words);
            }
            else if (token <= 284)
            {
                char words[10] = "OPERATOR";
                printf("<%d, %s>\n", token, words);
            }
            else if (token <= 292)
            {
                char words[10] = "SYMBOL";
                printf("<%d, %s>\n", token, words);
            }
            else
            {
                printf("<UNKNOWN>\n");
            }
        }
    }
    return 0;
}
```


### YY_DECL

```c
YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;
}
```

lex.yy.c有这么个东西，是yylex()的宏定义，然后会发现下面近300行都是我们写的一堆shit。看来这就是yylex()函数本体。

#### 翻译一下那堆代码

```c
int yylex(void) {
    // 局部变量声明
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;
    
    // 初始化代码
    if (yy_init) { ... }
    
    // 主循环
    while (1) {
        // 自动机进行正则表达式匹配
        // 状态匹配和动作执行
        // ...
        
        switch (yy_act) {
            // 开始执行我们规则区书写的代码
            // 各个词法规则对应的case
            case 1: // 规则1
            case 2: // 规则2
            // ...
        }
    }
}
```

## 问题解答

### 1.怎么就匹配一个？

`"int"     { printf("<%d, %s>\n", Y_INT, "KEYWORD"); return Y_INT; }`

```c
// .l中覆写main
void main(){
    yylex();
}
```

为什么规则里面有return，他就只能匹配一个，然后程序就中止了？

废话，都return了跳出while循环了。然后main又被重写成一个yylex。不就匹配一个停了。

### 2.哎那我们不重写main函数怎么样

```bash
PS D:\Study\paper\compile\practice\task1> gcc -o a lex.yy.c -I.
D:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/lib/../lib/libmingw32.a(lib64_libmingw32_a-crt0_c.o):crt0_c.c:(.text.startup+0x2e): undefined reference to `WinMain'
collect2.exe: error: ld returned 1 exit status
```
很明显，还是重写好

### 3.注释问题

`.l`文件里面的注释全是`/* */`。并且建议不要加注释，免得又出问题

### 4.FLOAT怎么匹配不了？

```flex
{FLOAT} {printf("<%d, %s>\n", num_FLOAT, yytext);}
{DIGIT16}   { printf("<%d, %s>\n", num_INT, yytext); }
{INT} { printf("<%d, %s>\n", num_INT, yytext); }
{ID} { printf("<%d, %s>\n", Y_ID, yytext); }
```

啊把`FLOAT`匹配改到前面，优先级提高，不然就匹配`INT . INT`

### 5.拿不到100

只能说ICODING狗屎。我不想瞎找问题。

### 6. `.l`文件规则区到底是写return还是不写？

* 写的话main就要多写，

* 不写的话没有返回值，但是应该也可以用变量接着。

很明显这是个问题，但是目前看来对于交ICODING没有影响，应该在传给语法分析器后，才会出现。

所以到时候再看