# 00 - 01

## **第00-01章：编译引论和概述**

**核心思想**：编译器是一个**翻译官**，它的任务是把用高级语言（如C++, Java, Python）写的**源程序**，翻译成计算机能直接或间接执行的**低级语言**（如汇编语言、机器码）。

**1. 编译 vs. 解释**
- **编译器**：像一位**笔译**。它把整本书（源程序）从头到尾翻译成另一种语言（目标程序），生成一个独立的可执行文件（如.exe）。之后运行这个文件即可。
- **解释器**：像一位**同声传译**。它边读源程序边执行，不生成独立的目标程序。每次运行都需要解释器在场。

**2. 编译的六大阶段（这是精髓！）**
这个过程可以类比**把一句英文翻译成地道的中文**：

| 编译阶段 | 英文翻译类比 | 编译器任务 |
| :--- | :--- | :--- |
| **1. 词法分析** | 识别单词 | 将字符序列（`if (x>0)`）转换成有意义的“单词”流（`IF, LEFT_PAR, ID(x), GT, NUM(0), RIGHT_PAR`） |
| **2. 语法分析** | 分析句子结构 | 根据语法规则，将单词组合成“语法树”。检查结构是否正确，比如括号是否匹配。 |
| **3. 语义分析** | 理解句子含义 | 进行类型检查、作用域分析等。确保“用整数除以字符串”这类无意义的操作能被发现。 |
| **4. 中间代码生成** | 初步翻译成通用句式 | 生成一种抽象、与硬件无关的中间表示（如三地址码、四元式），便于后续优化和翻译。 |
| **5. 代码优化** | 修饰译文，使其更优美高效 | 对中间代码进行等价变换，使最终程序运行更快、占用空间更小。 |
| **6. 目标代码生成** | 最终翻译成指定语言 | 将优化后的中间代码转换成特定CPU的汇编指令或机器码。 |

**3. 编译器结构总览**
这个图概括了所有阶段和数据流，请务必理解：
```
源程序 --> [词法分析器] --> 单词流 --> [语法分析器] --> 语法树 --> [语义分析与中间代码生成] --> 中间代码 --> [优化器] --> 优化后中间代码 --> [目标代码生成器] --> 目标程序
```
在整个过程中，**符号表管理**和**出错处理**模块与所有阶段交互，负责记录变量信息和管理错误。

## 编译的实例

```C
while (y < z) {
	int x = a + b;
	y += x;
}
```

### 词法分析

任务: 输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号

依循的原则：构词规则

描述工具：有限自动机

**识别一个一个的token，比如 y, z, x, a, b, int =, +, while, (, )....**

### 语法分析

任务：在词法分析的基础上，根据语法规则把单词符号串分解成各类语法单位(语法范畴)

依循的原则：语法规则

描述工具：上下文无关文法

判断公式写没写对，比如 + - 后面要跟一个值，

### 语义分析

检查语法正确的情况下是否有意义

### 中间代码生成以及优化

任务：对各类语法单位按语言的语义进行初步翻译

依循的原则：语义规则

描述工具：属性文法

中间代码：三元式，四元式（三地址代码），树，...
Z:=X + 0.618 * Y   翻译成四元式为

|序号| 运算符 | 操作数1 | 操作数2 | 结果 |
|:--| :--- | :--- |:-- | :--- |
|(1)| * | Y | 0.618 | T1 |
|(2)| + | X | T1 | T2 |
|(3)| = | T2 | - | Z |

### 目标代码生成以及优化

任务: 把中间代码变换成特定机器上的目标代码
依赖于硬件系统结构和机器指令的含义
目标代码三种形式
    绝对指令代码: 可直接运行 
    汇编指令代码: 需要进行汇编
    可重新定位指令代码: 需要连接

```c
while (y < z) {
	int x = a + b;
	y += x;
}
```
```
Loop:   add  $x, $a, $b
        slt  $_t1, $y, $z
        beq  $_t1, 1,  where_true
        j    where_false
where true: add  $y, $x, $y
            j    Loop
where false: next code

```

## 符号表

登记各类名字的信息

编译各阶段都需要使用符号表

    一致性检查和作用域分析

    辅助代码生成

按名字的不同种属建立多张符号表，如符号名表、常数表、标号表、入口名表、过程引用表、…

### 形式

键值对(名字域和属性域)

### 名字域

名字的长度，‘

### 属性域

## 前后端分离的思想

### 编译的前端

    词法分析，语法分析，语义分析，中间代码生成

### 编译的后端

    与目标机有关的优化，目标代码生成

**思考题**：
1.  为什么编译要分成这么多阶段？把所有工作混在一起做不行吗？
2.  “前端”和“后端”通常指哪几个阶段？这种分离有什么好处？

3. 语法分析和语义分析的边界

语法只看结构

A = b + ;  语法错误

语义看含义

int A = "hello" + 1; 语义错误